import math
import numpy as np

def f(x):
    return x * math.sin(3 * x) - math.exp(x)

def df(x):
    return math.sin(3 * x) + 3 * x * math.cos(3 * x) - math.exp(x)


x_newton = []
x_n = -1.6  # Initial guess
x_newton.append(x_n)
tolerance = 1e-6
max_iter = 1000
iteration_newton = 0

while abs(f(x_n)) > tolerance and iteration_newton < max_iter:
    f_xn = f(x_n)
    df_xn = df(x_n)
    if df_xn == 0:
        print("Zero derivative. No solution found.")
        break
    x_n1 = x_n - f_xn / df_xn
    x_newton.append(x_n1)
    x_n = x_n1
    iteration_newton += 1


a = -0.7
b = -0.4
if f(a) * f(b) >= 0:
    print("Bisection method fails.")
    x_bisect = []
    iteration_bisect = 0
else:
    x_bisect = []
    iteration_bisect = 0
    while (b - a) / 2.0 > tolerance:
        c = (a + b) / 2.0
        x_bisect.append(c)
        iteration_bisect += 1
        if f(c) == 0:
            break
        elif f(a) * f(c) < 0:
            b = c
        else:
            a = c

A1 = x_newton
A2 = x_bisect
A3 = [iteration_newton, iteration_bisect]

print("A1:", A1)
print("A2:", A2)
print("A3:", A3)



A = np.array([[1, 2],
              [-1, 1]])

B = np.array([[2, 0],
              [0, 2]])

C = np.array([[2, 0, -3],
              [0, 0, -1]])

D = np.array([[1, 2],
              [2, 3],
              [-1, 0]])

x = np.array([[1],
              [0]])

y = np.array([[0],
              [1]])

z = np.array([[1],
              [2],
              [-1]])


A4 = A + B

A5 = 3 * x - 4 * y

A6 = A @ x

A7 = B @ (x - y)

A8 = D @ x

A9 = D @ y + z

A10 = A @ B

A11 = B @ C

A12 = C @ D

print("A4:\n", A4)
print("A5:\n", A5)
print("A6:\n", A6)
print("A7:\n", A7)
print("A8:\n", A8)
print("A9:\n", A9)
print("A10:\n", A10)
print("A11:\n", A11)
print("A12:\n", A12)

